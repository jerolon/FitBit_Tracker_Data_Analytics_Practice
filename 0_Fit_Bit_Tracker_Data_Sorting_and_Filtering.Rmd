---
title: "Fit Bit Tracker Data Sorting and Filtering"
author: "Jeronimo Miranda"
date: '2023-05-05'
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(skimr)
library(dplyr)
library(lubridate)
library(stringr)
library(tidyr)
```

```{r directory setup, include = FALSE}
rstudioapi::getActiveDocumentContext
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```

## Loading and exploring the data
We are using the data from <https://www.kaggle.com/datasets/arashnic/fitbit>. 
Assume the path to the data is in a folder above where the repository is.

### Daily activity data

I am loading the Ids as character because summary statistics like mean or meadian are irrelevant whereas string comparisons like do all have the same amount of characters and how many are unique are important.

```{r data loading, message=FALSE, warning=FALSE}
data_path <- "../Fitabase Data 4.12.16-5.12.16/"
dailyActivity <- read_csv(paste0(data_path,"dailyActivity_merged.csv"), 
    col_types = cols(Id = col_character(), 
        ActivityDate = col_date(format = "%m/%d/%Y")))
skim_without_charts(dailyActivity)
```

Loaded the dates in the correct format. Since apart from date and Id all columns are numeric, it makes sense to use skim_without_charts which gives a statistical summary of each variable. The function output is rendered as an html table, which is quite nice.

What we can see from this summary:

* 33 unique Ids, all have 10 characters.
* Data was collected for 31 days.
* The minimum for **all** numeric variables is 0. This suggests empty days, maybe just days that people did not wear their devices. These rows should be eliminated.
* Column names do not need to be cleaned
* The data is in long format
* This data can help answer our question by telling us how frequently people track different activities. Before any analysis we can see that most activity is done via trackerDistance rather than LoggedActivities

Total distance is not the sum of TrackerDistance and LoggedActivitiesDistance, as one could assume. Rather it seems to be the sum of the ActiveDistances columns. Lack of metadata is killing me here.
```{r sum of distances}
filter(dailyActivity, TotalDistance != (LoggedActivitiesDistance + TrackerDistance))
```
#### Number of days tracked

We group the days by Id and then plot a histogram of how many days people in the dataset were tracked
```{r number of days tracked, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
select(dailyActivity, Id, ActivityDate) %>% group_by(Id) %>% summarise(N_days = n()) %>% ggplot() + geom_histogram(aes(x = N_days)) + theme_bw() + 
  labs(title = "Days of activity", subtitle = "Frequency of the number of days tracked per user")
```

Running `select(dailyActivity, Id, ActivityDate) %>% distinct()` shows that there are no duplicate dates for any Id

Data seems very redundant. The files `dailyCalories_merged.csv`, `daily_Intensities_merged` and `dailySteps_merged.csv` are just column subsets of `dailyActivity_merged.csv`

### Heartrate seconds data

```{r load heart rate, warning=FALSE}
heartrate_seconds <- read_csv(paste0(data_path,"heartrate_seconds_merged.csv"), 
    col_types = cols(Id = col_character(), Time = col_character(), Value = col_double()))
heartrate_date_time <- transmute(heartrate_seconds, Id, date_time = mdy_hms(Time), Value, hour_of_day = hms::as_hms(date_time), dia = date(date_time))
skim_without_charts(heartrate_date_time)
```

Only 14 out of 33 volunteers use a tracker that gets heart-rate data

These graphics span 24 hour periods. So you can see that only 3 people do not use the device to track sleep. The data is smoothed for every user, so day to day variability is lost. Still you can see some patterns of when people tend to exercise more consistently. Later we can average by the heart rate in sliding windows to plot different days for each user. It is just that the raw data every 5 seconds is way too dense to be visualized directly, even for a single day for a single user.

```{r graph of heart rates, echo=FALSE}
heartrate_date_time %>% ggplot() + geom_smooth(aes(x = hour_of_day, y = Value), se=FALSE) + facet_wrap(~Id) + labs(title = "Heart rate throught the day", subtitle = "Trendline of heart rate per user")
```

### Loading and checking hourly data
Finally figured out how to parse date times from readr. There are three files with hourly aggregated data. Skim without chart is done after merging all three files.
```{r hourly loading, warning=FALSE}
hourlyCalories <- read_csv(paste0(data_path, "hourlyCalories_merged.csv"), 
    col_types = cols(Id = col_character(), 
        ActivityHour = col_datetime(format = "%m/%d/%Y %H:%M:%S %p")))

hourlyIntensities <- read_csv(paste0(data_path, "hourlyIntensities_merged.csv"), 
    col_types = cols(Id = col_character(), 
        ActivityHour = col_datetime(format = "%m/%d/%Y %H:%M:%S %p")))

hourlySteps <- read_csv(paste0(data_path, "hourlySteps_merged.csv"), 
    col_types = cols(Id = col_character(), 
        ActivityHour = col_datetime(format = "%m/%d/%Y %H:%M:%S %p")))
hourlyActivity <- inner_join(hourlyCalories, hourlyIntensities, by = c("Id","ActivityHour")) %>% inner_join(hourlySteps, by = c("Id", "ActivityHour"))

skim_without_charts(hourlyActivity)
```

- All three datasets are complete, the joins by Id and hourlyActivity conserve the 22099 hours.
- What is Intensity? How is it defined and why does it not appear in dailyActivity? Maybe it is some function of hear-rate and steps.

There is data for 24 hours most days. Does this mean that people almost never take off their devices? Or just that there is hourly data regardless of whether people wear their fitbits?

```{r hoursTracked, echo=TRUE, message=FALSE, warning=FALSE}
hourlyActivity %>% mutate(fecha = date(ActivityHour)) %>% group_by(fecha, Id) %>% summarise(hoursTracked = n()) %>% ungroup() %>% group_by(hoursTracked) %>% summarise(days = n()) %>% arrange(desc(hoursTracked))
```

Take the intervals between rows. All NAs are when users Id change. All other gaps are one hour long. Hard to think that users wore their fitbits for two months continuously. Heart rate data can be used in the analysis section to answer this question.

```{r duration of tracking per user}
hourlyActivity %>% select(Id, ActivityHour) %>% mutate(fecha = date(ActivityHour)) %>% group_by(Id) %>% mutate(gap = ActivityHour - lag(ActivityHour)) %>% ungroup() %>%  group_by(gap) %>% summarise(gaps = n())
```
### Loading minute data

Minute data has the peculiarity that each feature is present in **Wide** and **Narrow** modalities. My first guess was *Wide* meant that each user had its oen column, but it is actually that files have a row per hour and each column is a minute. This is awful, but a good opportunity to try the package called "lubridate".

The features present with minute resolution are:

- Calories
- Intensities
- Steps
- METs (Only present in narrow format God knows why)
- Sleep (Not specified whether it is narrow or wide format)

#### Calories by the minute

```{r minute calories, echo=TRUE, message=FALSE, warning=FALSE}
minuteCaloriesNarrow <- read_csv(paste0(data_path, "minuteCaloriesNarrow_merged.csv"), 
    col_types = cols(Id = col_character(), 
        ActivityMinute = col_datetime(format = "%m/%d/%Y %H:%M:%S %p")))

minuteCaloriesWide <- read_csv(paste0(data_path,"minuteCaloriesWide_merged.csv"), 
    col_types = cols(Id = col_character(), 
        ActivityHour = col_datetime(format = "%m/%d/%Y %H:%M:%S %p")))

#This Transforms the wide data to narrow
minuteCalWide_toNarrow <- minuteCaloriesWide %>% pivot_longer(names_to = "Minute", values_to = "Calories", cols = starts_with("Calories"), names_transform = readr::parse_number)

#Note the "minutes" function when adding to ActivityHour, otherwise the numeric column would get added as seconds
minuteCalWide_toNarrow <- minuteCalWide_toNarrow %>% transmute(Id, ActivityMinute = ActivityHour + minutes(Minute), Calories) %>% arrange(Id)

```

#### Discrepancies between the files

Already the number of rows differs between both files
```{r calorie comparison, echo=TRUE, message=FALSE, warning=FALSE}
nrow(minuteCaloriesNarrow) - (60 * nrow(minuteCaloriesWide))
```
The minuteCaloriesNarrow file and the minuteCaloriesNarrow differ in data, for some random reason.

We will just make a new minuteCalories object as the intersection of both files, the Wide file previously transformed to long format in a chunk above. Delete the intermediate files to save memory

```{r minute calories merged, message=FALSE, warning=FALSE}
minuteCalories <- union(minuteCaloriesNarrow, minuteCalWide_toNarrow)
rm(minuteCaloriesNarrow)
rm(minuteCalWide_toNarrow)
```

Now we will compare these data with the previously loaded hourly data. In the code below, note the combination of the functions `hours` which transforms a number to hours and `hour` which extracts the hour info from a date time.

```{r comparison of minute and hour data, message=FALSE, warning=FALSE}
minuteCalories 

#Group the minuteCalories by hour and sum the cals. A column in the summerise function lets us check that we are not including hours where not all minutes are present
minuteCalories2hour <- minuteCalories %>% transmute(Id, ActivityHour = date(ActivityMinute) + hours(hour(ActivityMinute)), Calories) %>% group_by(Id, ActivityHour) %>% summarise(Calories = round(sum(Calories)), n_minutes = n())

minuteCalories2hour <- minuteCalories2hour %>% filter(n_minutes == 60) %>% select(-n_minutes)
setdiff(minuteCalories2hour, hourlyCalories)
```

Comparing the two files, it seems what happened is that in the hourly data, all days without the full 24 hours were dropped. This is understandable, since later this data was used for daily data, so keeping less than 24 hour days would have resulted in bias for some days. On the other hand, for the picture of device use, complete hourly data can be useful.

